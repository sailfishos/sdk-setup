#!/bin/bash

# This is a helper script for the Mer SDK to manage sb2 target and
# toolchain installation

sdk_user=mersdk
mer_targets=/srv/mer/targets
host_targets=/host_targets
sbox2dir=/home/$sdk_user/.scratchbox2
target_xml=${host_targets}/targets.xml

usage()
{
    cat <<EOF
    usage (keep the arguments order):

           $0 --toolchain --list
           $0 --toolchain --install <arch>
           $0 --toolchain --remove <arch>

           $0 --target --list
           $0 --target --upgradable <name>
           $0 --target --install <name> <toolchain> <url>
           $0 --target --remove  <name>
           $0 --target --refresh [--all | <name> [<name>...]]
           $0 --target --update <name>
           $0 --target --sync <name>
           $0 --target --import <name>
           $0 --target --register --user <uname> --password <pass> --all | <tname> [<tname>...]

           $0 --devel --list <target> [<search string>]
           $0 --devel --install <target> <devel package list>
           $0 --devel --remove <target> <devel package list>

           $0 --sdk --version
           $0 --sdk --refresh
           $0 --sdk --upgradable
           $0 --sdk --upgrade
           $0 --sdk --status
           $0 --sdk --register --user <name> --password <pass>

           $0 --refresh-all

           $0 --register-all --user <username> --password <password>

       This is the Mer SDK VM manager
       For information see https://wiki.merproject.org/wiki/Platform_SDK_on_VirtualBox
       It is primarily intended for use by the SDK web interface.


EOF
    [[ ${1:-} == "--exit" ]] && { exit 1; }
    return 0
}

if [[ $EUID -ne 0 ]]; then
    exec sudo $0 "$@"
    echo "$0 must be run as root and sudo failed; exiting"
    exit 1
fi

# From now on, exit if variables not set
set -u

# Make sure normal users can use any dirs we make
umask 022


################################################################'
# toolchain

# Our toolchains are available through zypper as Mer-SB2-* patterns

get_toolchains() {
    zypper --no-refresh --non-interactive search -t pattern Mer-SB2-* | grep Mer-SB2 | while IFS='| ' read installed pkg dummy; do
	echo "${pkg},${installed}"
    done
    return ${PIPESTATUS[0]}
}

ensure_installed() {
    get_toolchains | egrep -s "^$1,i$" >/dev/null
}

ensure_installable() {
    get_toolchains | egrep -s "^$1,$" >/dev/null
}

install_toolchain() {
    pkg=$1
    if ensure_installable $pkg; then
	zypper --non-interactive install -t pattern $pkg
	return $?
    else
	echo "Toolchain $pkg doesn't exist or is already installed- can not install."
	exit 2
    fi
}

remove_toolchain() {
    pkg=$1
    if ensure_installed $pkg; then
	zypper --no-refresh --non-interactive remove -t pattern $pkg
	return $?
    else
	echo "Toolchain $pkg is not installed - can not remove."
	exit 2
    fi
}

manage_toolchains() {
    if ! [[ $1 ]]; then
	usage --exit
    fi

    case "$1" in
	--list )
	    get_toolchains
	    return $?
	    ;;
	--install ) shift
	    install_toolchain "$@"
	    return $?
	    ;;
	--remove ) shift
	    remove_toolchain "$@"
	    return $?
	    ;;
	* )
	    echo "$1 not recognised"
	    usage --exit
	    ;;
    esac
}

################################################################'
# Devel packages

# Our devel packages are available through zypper as -devel packages :)

assert_target_and_setup() {
    assert_target_name_valid "$target"
    if ! [[ -f $sbox2dir/$target/sb2.config ]]; then
	echo "Target $target is not a valid Scratchbox2 target"
	exit 1
    fi

    if [[ $(check_target_visible $target) == "no" ]]; then
	echo "Target $target is not accessible"
	exit 1
    fi
}

t_zypper() {
    (
	sudo -i -u $sdk_user bash -c "sb2 -t $target -m sdk-install -R zypper $*"
    )
}

get_develpkgs() {
    search=${1:-}
    t_zypper --non-interactive --no-refresh search -- "$search" 2>&1 | sed '0,/---------/d' | while IFS='| ' read installed pkg dummy; do
	echo "${pkg},${installed}"
    done
    return ${PIPESTATUS[0]}
}

manage_develpkgs() {
    if ! [[ {$1:-} ]]; then
	usage --exit
    fi

    case "$1" in
	--list ) shift
	    target=${1:-}
	    search=${2:-}
	    assert_target_and_setup
	    get_develpkgs $search
	    return $?
	    ;;
	--install ) shift
	    target=${1:-}
	    assert_target_and_setup
	    shift
	    t_zypper --non-interactive --no-refresh install "$@"
	    synchronise_target $target
	    return $?
	    ;;
	--remove ) shift
	    target=${1:-}
	    assert_target_and_setup
	    shift
	    t_zypper --non-interactive --no-refresh remove "$@"
	    synchronise_target $target
	    return $?
	    ;;
	* )
	    echo "$1 not recognised"
	    usage --exit
	    ;;
    esac
}

################################################################
# Targets

t_register() {
    local domain
    local tgt
    [[ -z ${1:-} ]] && return 0

    tgt=$1
    domain=$(sudo -i -u $sdk_user bash -c "sb2 -t $tgt sdk-register -d")
    if [[ z"$domain" == zjolla ]]; then
	echo -n "$tgt: "
	sudo -i -u $sdk_user bash -c "sb2 -t $tgt -m sdk-install -R sdk-register -u $reg_username -p $reg_password"
    else
	echo "$tgt: Register not needed (domain: ${domain:-empty})"
    fi
}

check_target_visible() {
    set +u
    local tgt=$1
    . $sbox2dir/$tgt/sb2.config
    if [ ! -d "$SBOX_TARGET_ROOT" ]; then
	echo "no"
	return
    fi
    set -u
    echo "yes"
}

get_targets() {
    tgts=$(sudo -i -u $sdk_user sb2-config -l 2>&1)
    [[ $? -ne 0 ]] && return 0

    for t in $tgts; do
	if [[ $(check_target_visible $t) == "yes" ]]; then
	    echo $t
	fi
    done
}

assert_target_name_valid() {
    if [[ $# -lt 1 ]] || [[ -z $1 ]]; then
      echo "Target name missing."
      exit 1
    fi

    pat='^[-[:alnum:]_.]*$'
    if [[ $1 ]] && [[ $1 =~ $pat ]] ; then
      return
    fi

    echo "Target name '$1' is not a valid Scratchbox2 target name."
    exit 1
}

synchronise_target() {
    # This is now a minimal set of files to sync
    if ! [ -d $mer_targets/$1 ]; then
	echo No target called $1
	return
    fi
    echo "Synchronising target to host"
    # The filter=". -" means to read filters from stdin (the <<EOF)
    rsync -a --no-devices --no-specials \
          --delete --ignore-errors \
	  --prune-empty-dirs  --copy-links \
	  --filter=". -" \
	  $mer_targets/$1/. $host_targets/$1/. <<EOF
# Ensure all dirs are copied (--prune-empty-dirs will clean up)
+ */
# We want this for QtCreator to determine the architecture
+ /usr/lib/libQt*Core.so
# Don't need any other .so files
- *.so
# All the import, include and qt* shares
+ /usr/lib/qt*/imports**
# Qt5 qml imports are here
+ /usr/lib/qt5/qml**
+ /usr/include**
+ /usr/share/qt**
# and nothing else
- *
EOF
    # We need /usr/bin/stopCreatorSegfaulting for Creator's happiness
    mkdir -p $host_targets/$1/usr/bin
    touch $host_targets/$1/usr/bin/stopCreatorSegfaulting
    # For Qt5, QtCreator needs to see this dir or it thinks Qt version is not properly installed
    mkdir -p $host_targets/$1/usr/lib/qt5/bin/

    echo "Sync completed"
}

import_target() {
    # This could be minimised in the future if sf is not fixed
    # Ignore errors as we sometimes have dangling symlinks and
    # still want to keep clean
    if ! [ -d $host_targets/$1 ]; then
	echo No host target called $1
    fi
    rsync -a --no-devices --no-specials \
          --delete --ignore-errors \
	  $host_targets/$1/ $mer_targets/$1
}

# create a unique device-id for the target
target_uuidgen()
{
    local mytarget=$1

    if [[ -z "$mytarget" ]]; then
	echo "NOTICE: target_uuidgen: empty target name given"
	return 0
    fi

    echo "target_uuidgen: generating a unique id for $mytarget target"
    sudo -i -u $sdk_user bash -c "sb2 -t $mytarget -m sdk-install -R rm -f /var/lib/dbus/machine-id"
    sudo -i -u $sdk_user bash -c "sb2 -t $mytarget -m sdk-install -R dbus-uuidgen --ensure"
}

# Download and install a rootfs
install_target() {
    skip_toolchain_check=0
    if [[ "$1" == "--jfdi" ]]; then
	# Sometimes you want to install without checking the toolchain - jfdi
	skip_toolchain_check=1; shift;
    fi
    target=$1
    toolchain=$2
    url=$3 #FIXME: check url validity
    if ! [[ $skip_toolchain_check ]]; then
	echo Making sure the right toolchain exists
	if ! ensure_installed $toolchain; then
	    echo "Installing required toolchain: $toolchain"
	    install_toolchain $toolchain
	fi
    fi

    local_file=""
    local target_downloaded=0
    if [[ $url == file\:\/\/\/* ]]; then
	local_file=${url//file\:\/\//}
    else
	echo Downloading target
	local_file=$mer_targets/$target.tar.bz2
	echo "curl $url > $local_file"
	curl -# "$url" > $local_file
	curl_status=$?
	if [ \( $curl_status -ne 0 \) -o \( $(stat -c %s "$local_file") -lt 10000 \) ]; then #hash check anybody?
	    echo "Download failed"
	    rm -f $local_file
	    return 3
	fi
	target_downloaded=1
    fi

    # Virtualbox shared folders don't work too well at the moment
    # Unpack targets to a private area within the VM
    rm -rf $mer_targets/$target
    mkdir -p $mer_targets/$target
    mkdir -p $host_targets/$target

    cd $mer_targets/$target

    echo
    echo Unpacking target
    tar xf "$local_file"
    local tar_retcode=$?

    if [[ ! -z $local_file ]]; then
	if [[ $target_downloaded -eq 1 ]]; then
	    rm -f "$local_file"
	fi
    else
	rm -f "$mer_targets/$target.tar.bz2"
    fi

    if [ $tar_retcode -ne 0 ]; then
	if [ "$( df --sync / | tr -s ' ' | tail -n 1 | cut -d ' ' -f 4 )" -lt 10000 ]; then
	    echo "Not enough disk space to unpack target image"
	else
	    echo "Could not unpack target image"
	fi
	rm -rf $mer_targets/$target
	return 4
    fi

    chown -R $sdk_user:$sdk_user $mer_targets/$target

    synchronise_target $target
    [ $? -ne 0 ] && echo "Rsync didn't exactly run as intended, expect problems."

    echo Setting up SB2

    case $toolchain in
	*-arm*)
	    architecture=$(echo $toolchain | tr '-' '\n' | tail -n 1)
	    transparency="-c /usr/bin/qemu-arm-dynamic"
	    compiler="/opt/cross/bin/$architecture-meego-linux-gnueabi-gcc"
	    toolsdir="-t /"
	    ;;
	*-mipsel)
	    transparency="-c /usr/bin/qemu-mipsel-dynamic"
	    compiler="/opt/cross/bin/mipsel-meego-linux-gnu-gcc"
	    toolsdir="-t /"
	    ;;
	*-i486*)
	    transparency=""
	    compiler="/opt/cross/bin/i486-meego-linux-gnu-gcc"
	    toolsdir=""
	    ;;
    esac

    sudo -i -u $sdk_user bash -c "cd $PWD; sb2-init -L \"--sysroot=/\" -C \"--sysroot=/\" $transparency -m sdk-build -n -N $toolsdir $target $compiler"

    # make sure the created target gets a unique id
    target_uuidgen $target

    assert_target_and_setup

    echo Notifying QtCreator of new target
    sudo -i -u $sdk_user updateQtCreatorTargets --name $target --target-xml $target_xml

    echo Target $target now setup
}

remove_target() {
    target=$1
    if [ -d $sbox2dir/$target ]; then
	rm -r $sbox2dir/$target
	rm -rf $mer_targets/$target
	rm -rf $host_targets/$target

	echo "Notifying QtCreator of removed target"
    else
	echo "Note: target $target was not seen by sb2"
    fi

    # Notify QtCreator anyways, in case the target information was not
    # in sync
    sudo -i -u $sdk_user updateQtCreatorTargets --delete --name $target --target-xml $target_xml
}


manage_targets() {
    if ! [[ ${1:-} ]]; then
	usage --exit
    fi

    case "${1:-}" in
	--list )
	    get_targets
	    ;;
	--upgradable ) shift
	    target="${1:-}"
	    assert_target_and_setup
	    t_zypper --non-interactive --no-refresh --quiet list-updates
	    ;;
	--install ) shift
	    assert_target_name_valid "${1:-}"
	    install_target "$@"
	    ;;
	--remove ) shift
	    assert_target_name_valid "${1:-}"
	    remove_target "$@"
	    ;;
	--refresh ) shift
	    if [[ "${1:-}" == "--all" ]]; then
		local targets=$(get_targets)
	    else
		local targets="$@"
	    fi
	    for target in $targets; do
		assert_target_and_setup
		t_zypper --non-interactive refresh
	    done
	    ;;
	--update ) shift
	    target="${1:-}"
	    assert_target_and_setup
	    t_zypper --non-interactive dup
	    ;;
	--sync ) shift
	    target="${1:-}"
	    assert_target_name_valid "$target"
	    synchronise_target "$@"
	    sudo -i -u $sdk_user updateQtCreatorTargets --name $target --target-xml $target_xml
	    ;;
	--import ) shift
	    assert_target_name_valid "${1:-}"
	    import_target "$@"
	    ;;
	--register ) shift
	    local alltargets
	    get_register_credentials "$@"
	    shift $reg_shift

	    if [[ "${1:-}" == "--all" ]]; then
		local targets=$(get_targets)
		alltargets=1
		shift
	    else
		local targets="$@"
	    fi

	    # Fail here if --all was not used and no targets were given
	    [[ -z "$targets" ]] && [[ -z "$alltargets" ]] && usage --exit

	    for target in $targets; do
		assert_target_and_setup
		t_register $target
	    done
	    ;;
	* )
	    echo "$1 not recognised"
	    usage --exit
	    ;;
    esac
}

################################################################
# SDK

get_sdk_version() {
    echo "Version not available"
}

upgrade_sdk() {
    zypper --non-interactive refresh -f
    zypper --non-interactive dup
}

refresh_sdk() {
    zypper --non-interactive refresh -f
}

register_sdk() {
    local domain
    get_register_credentials "$@"
    domain=$(sdk-register -d)
    if [[ z"$domain" == zjolla ]]; then
	echo -n "MerSDK: "
	sdk-register -u ${reg_username:-} -p ${reg_password:-}
    else
	echo "MerSDK: Register not needed (domain: ${domain:-empty})"
    fi
}

sdk_status() {
    systemctl --failed
    ERR=$?
    if sudo VBoxControl -nologo sharedfolder list | grep ' home$' > /dev/null 2>&1 ; then
	echo "'home' shared folder is missing"
	ERR=1
    fi
    if sudo VBoxControl -nologo sharedfolder list | grep ' config$' > /dev/null 2>&1 ; then
	echo "'config' shared folder is missing"
	ERR=1
    fi
    if sudo VBoxControl -nologo sharedfolder list | grep ' targets$' > /dev/null 2>&1 ; then
	echo "'targets' shared folder is missing"
	ERR=1
    fi
    exit $ERR
}

manage_sdk() {
    if ! [[ ${1:-} ]]; then
	usage --exit
    fi

    case "$1" in
	--version )
	    get_sdk_version
	    ;;
	--status )
	    sdk_status
	    ;;
	--upgradable ) shift
	    zypper --non-interactive --no-refresh --quiet lu
	    ;;
	--upgrade ) shift
	    upgrade_sdk "$@"
	    ;;
	--refresh )
	    refresh_sdk
	    ;;
	--register ) shift
	    # expects --user and --password
	    register_sdk "$@"
	    ;;
	* )
	    echo "$1 not recognised"
	    usage --exit
	    ;;
    esac
}


################################################################
# utility

get_register_credentials() {
    set +u
    reg_username=
    reg_password=
    reg_shift=0
    while [[ "${1:-}" ]]; do
	case "$1" in
	    --user )
		[ -z "$2" ] && usage --exit
		reg_username="$2"
		(( reg_shift=reg_shift+2 ))
		shift 2
		;;
	    --password )
		[ -z "$2" ] && usage --exit
		reg_password="$2"
		(( reg_shift=reg_shift+2 ))
		shift 2
		;;
	    *)
		break
		;;
	esac
    done
    if [ -z "$reg_username" ] || [ -z "$reg_password" ]; then
	usage --exit
    fi

    set -u
}

################

################################################################
# Main

if ! [[ ${1:-} ]]; then
    usage --exit
fi

case "$1" in
    --toolchain ) shift
	manage_toolchains "$@"
	;;
    --target ) shift
	manage_targets "$@"
	;;
    --devel ) shift
	manage_develpkgs "$@"
	;;
    --sdk ) shift
	manage_sdk "$@"
	;;
    --refresh-all ) shift
	manage_targets --refresh --all
	manage_sdk --refresh
	;;
    --register-all ) shift
	# expects to get --user and --password too
	manage_sdk --register "$@"
	manage_targets --register "$@" --all
	;;
    * )
	echo "$1 not recognised"
	usage --exit
	;;
esac
