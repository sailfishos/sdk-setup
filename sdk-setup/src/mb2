#!/bin/bash
#
# Copyright (C) 2013 - 2016 Jolla Ltd.
# Contact: David Greaves <david.greaves@jollamobile.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# - Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

short_usage() {
    cat <<EOF
usage: $ME [-t <target>] [-s <specfile>] [-d <device>] [-p <projectdir>]
           [-f <folder>] [-i] [-P] [-x[=<tag>] | -X] [-c[=<args>]]
           build [-p] [-d] [-j <n>] [<args>] | qmake [<args>] | make [<args>] | ssh <args>
           install [<args>] | installdeps <args> | rpm [<args>] | deploy <args>
           prep | apply [-R] | run <args>
       $ME --version
       $ME --help
EOF
    # exit if any argument is given
    [[ -n "$1" ]] && exit 1
}

usage() {
    short_usage
    cat <<EOF

  Executes a subset of build commands in the context of an rpmbuild.
  Typically called from QtCreator to perform qmake/make phases of a project.
  Note that any other build steps in the .spec file will also be run.

  <specfile> will be looked for in the current rpm/ dir. If there is
  more than one it must be provided.

  CWD is used as a base dir for installroot/ and RPMS/ to allow for
  shadowbuilds

  $ME is aware of spectacle and will update the spec file if there is
  an obvious yaml file which is newer.

  If a file exists with '.changes' extension, otherwise matching the
  spec file name, the effect will be the same as having a %changelog
  section in the spec file.  If a file with '.changes.run' extension is
  found instead, this file will be executed and its output treated as
  the actual changelog.

  $ME prep           : runs rpmbuild for %prep phase of the spec file.

  $ME build [-p|--doprep] [-d|--enable-debug] [-j <n>] [<args>]
                     : runs rpmbuild for the given spec file in the
                       given sb2 target. Produces an rpm package.
                     : -p     run %prep phase as well when building
                     : -d     enable debug build
                     : -j <n> use only 'n' CPUs to build
                     : can use -s -t -p -i -x -X -c

  $ME qmake [<args>] : runs qmake in the 'build' phase
                       Note that this also verifies target
                       build dependencies are up to date
                     : can use -s -t -p  

  $ME make [<args>]  : run make in the 'build' phase
                     : can use -s -t -p

  $ME deploy --zypper|--pkcon|--rsync|--sdk
                     : runs the install or rpm-creation phase and then
                       copies/installs the relevant files to the device
                     : can use -s -t -p -d -i -f -x -X -c

  $ME run|ssh [<args>] : runs a command (on device if --device given);
                         intended for running gdb and a gdb server
                     : can use -s -t -p -d

  $ME install [<args>] : runs the 'install' phase to install to $buildroot
                     : can use -s -t -p

  $ME installdeps [<args>] : refresh the zypper cache of the given target and
                             if required installs build-dependencies
                     : can use -s -t -p

  $ME rpm [<args>]   : runs the install & rpm-creation phases
                     : can use -s -t -p -i -x -X -c

  $ME apply [-R]     : applies all patches defined in spec from rpm directory
                     : to the source tree, or if detected, submodule
                     : source tree
                     : -R    reverse apply patches (patch -R)
                     : can use -m

  -i | --increment     : increment release number in spec file
  -t | --target        : specify the sb2 target to use
  -d | --device        : specify the device
  -p | --projectdir    : when running shadow build/deploy from another dir
  -s | --specfile      : if the specfile is not in rpm/*.spec and cannot be found using -p
  -f | --shared-folder : the folder where QtCreator shares devices.xml and ssh keys
                         this option is useful if deploy option is used outside of virtual
                         machine
  -P | --pedantic      : do extra checks
  -x[=<tag>] | --fix-version[=<tag>]
                       : this option is implied when used inside a Git working
                         tree from within a platform SDK (use -X to override).
                         Use the latest tag from the current git branch as
                         package version or the given <tag>.  If the current
                         HEAD, index or working tree differs from the tree
                         denoted by the tag, a suffix composed from the current
                         branch name, time stamp and a commit SHA1 will be added
                         to the package version.  If git-state is not clean
                         a git-stash will be created and its SHA1 will be used
                         instead of HEAD.
  -X | --no-fix-version
                       : override --fix-version option.
  -c[=<args>] | --git-change-log[=<args>]
                       : include change log generated from Git history with
                         'git-change-log' command, forwarding any <args>.
                         This option is not intended for regular use - create a
                         script file named after the spec file but with
                         '.changes.run' extension to instruct $ME to generate
                         changelog with 'git-change-log <args>' instead.
  -m | --submodule     : use specified directory as submodule when applying patches

EOF
}

notice() {
    echo "NOTICE: $*" >&2
}

fatal() {
    echo "Fatal: $*" >&2
    exit 1
}

# readarray is a bash >= 4.0 feature
if ! type readarray &>/dev/null; then
    readarray() {
        if ! [[ $# -eq 2 && $1 == -t && $(declare -p "$2" 2>/dev/null) == "declare -a "* ]]; then
            fatal "Internal error: readarray: unimplemented case"
        fi

        local line=
        eval $2=\(\)
        while IFS= read -r line; do
            eval $2=\(\${$2[@]:+\"\${$2[@]}\"} \"\$line\"\)
        done
    }
fi

check_spec_supports_qtc_silent() {
    grep "define qtc_qmake" "$OPT_SPEC" >/dev/null 2>&1
}

check_spec_supports_qtc() {
    if ! check_spec_supports_qtc_silent; then
        notice "This specfile does not have the qtc_* macros defined"
    fi
}

try_to_make_spec() { # Tries to create a missing spec
    [[ -f "$1" ]] && return # It's not missing
    local yaml="${1%.spec}.yaml"
    [[ -f "$yaml" ]] || return # No yaml
    ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
}

try_to_make_spec_from_yaml() {
    # Tries to create a missing spec from a given yaml
    try_to_make_spec "${1%.yaml}.spec"
}

sanitize_changelog() {
    sed 's/%/%%/g'
}

try_to_make_changelog() {
    local changes_file=${OPT_SPEC%.spec}.changes
    local changes_run_file=${OPT_SPEC%.spec}.changes.run

    if [[ $OPT_GIT_CHANGE_LOG ]]; then
        notice "Auto generating changelog from Git history ..."
        echo "%changelog"
        git-change-log $OPT_GIT_CHANGE_LOG_ARGS |sanitize_changelog
    elif [[ -f $changes_file ]]; then
        notice "Appending changelog entries to spec ..."
        echo "%changelog"
        cat $changes_file |sanitize_changelog
    elif [[ -f $changes_run_file ]]; then
        notice "Generating changelog entries with $changes_run_file ..."
        local runner=
        # In build VM the shared filesystem is noexec
        if ! [[ -x $changes_run_file ]]; then
            if [[ $(head -c 3 <$changes_run_file |cat -v) == '#!/' ]]; then
                runner=$(sed -n '1s/^#!//p' $changes_run_file)
            else
                fatal "Not executable: $changes_run_file"
            fi
        fi
        echo "%changelog"
        $runner $changes_run_file |sanitize_changelog
        [[ ${PIPESTATUS[0]} -eq 0 ]] || fatal "unable to generate changelog entries"
    fi
}

ensure_spec_newer_than_yaml() {
    local yaml="${OPT_SPEC%.spec}.yaml"
    if [[ -f "$yaml" ]] && [[ "$yaml" -nt "$OPT_SPEC" ]]; then # -nt is newer than
        ANSI_COLORS_DISABLED=1 specify -n -N "$yaml" || fatal "unable to convert yaml to spec"
    fi

    # it's ok also not to have a yaml
}

verify_target_dependencies() {
    local deps=()
    readarray -t deps < <(sb2 -t "$OPT_TARGET" rpmspec --query --buildrequires "$OPT_SPEC" |sed 's/\s*$//')
    if [[ $deps ]]; then
        sb2 -t "$OPT_TARGET" -m sdk-install -R zypper --quiet --non-interactive in "${deps[@]}"
    fi
}

get_spec_tag() {
    rpmspec --query --srpm --queryformat="$1" "$OPT_SPEC"
}

fix_package_version() {
    [[ ! $OPT_FIX_VERSION ]] && return

    local tag
    if [[ $OPT_FIX_VERSION_HINT ]]; then
        tag=$OPT_FIX_VERSION_HINT
    else
        if ! tag=$(git describe --tags --abbrev=0 2>/dev/null); then
            notice "No tags describe the HEAD, will not fix package version."
            return
        fi
    fi

    local version=$tag
    version=${version#*/}   # allow tags to have a prefix to allow vendor marking
    version=${version#v}    # some people like to prefix versions with a v

    local head
    if [[ $(git status --short --untracked-files=no) ]]; then
        head=$(git stash create)
    else
        head=$(git rev-parse HEAD)
    fi

    if [[ $(git rev-parse "$tag^{}") != "$head" ]]; then
        local branch=$(git rev-parse --abbrev-ref HEAD)
        local timestamp=$(TZ=UTC date --date=@$(git log --max-count=1 --pretty=%ct "$head") +%Y%m%d%H%M%S)
        local sha1sum=$(git rev-list --max-count=1 --abbrev-commit "$head")
        version=$version+$branch.$timestamp.$sha1sum
    fi

    version=${version//-/+} # '-' is not an allowed character in the version field

    echo "Setting version: ${version}"
    sed -i "s,^Version:.*,Version: ${version}," "$1"
}

# Helper to read XML
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    return $RET
}

# This slurps the XML and converts tags like <subnet> to $device_subnet
# Also sets device_name and device_type from the attributes
get_device() {
    local FOUND_DEVICE=
    local IN_DEVICE=
    local maintag=
    while read_dom; do
        case $TAG_NAME in
            device )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                if [[ "$name" == "$1" ]] ; then
                    FOUND_DEVICE=1
                    IN_DEVICE=1
                    device_name="$name"
                    device_type="$type"
                else
                    IN_DEVICE=
                fi
                ;;
            engine )
                maintag=$TAG_NAME
                eval local $ATTRIBUTES
                ;;
            mac|index|subnet|ip|sshkeypath )
                # Don't process and store nested tags if we're in
                # device with wrong name
                if [[ "$maintag" == "device" ]] && [[ $IN_DEVICE != 1 ]]; then
                    continue
                fi
                eval ${maintag}_$TAG_NAME=\"$CONTENT\"
                ;;
        esac
    done
    # Set this up as it's useful
    if [[ "$device_subnet" ]]; then
        device_ip="$device_subnet".$device_index
    fi
    if [[ "$FOUND_DEVICE" == 1 ]]; then return 0; else return 1; fi
}

rsync_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml (rsync $key)"
    RSYNC_RSH="ssh -F /etc/ssh/ssh_config.sdk -l $user -i \"$key\"" rsync "$@"
}

ssh_as() {
    local user="$1";shift
    local key=$(get_shared_dir)/${device_sshkeypath}/$user
    [[ -f "$key" ]] || fatal "No key for user $user on $device_name given in devices.xml ($key)"
    ssh -F /etc/ssh/ssh_config.sdk -i "$key" -l $user $device_ip "$(quote "$@")"
}

cd_to_spec_setup_dir() {
    _basedir="$PWD"

    # avoid spawning another process for | cut -s -f2 -d '/'
    local setup_dir=$(grep -Po '%setup.*-n.*' "$OPT_SPEC")
    # if setup_dir has '/' return the part after it
    setup_dir=${setup_dir/#*\//}
    # if it did not have a '/' then we got the original match => erase it
    setup_dir=${setup_dir/#%setup*/}

    if [[ -n "$setup_dir" ]]; then
    # in case we got a spec %{tag} out of this, try to expand it
    setup_dir=$(get_spec_tag "$setup_dir")
    cd "$setup_dir"
    fi
}

# handle release tags with format "x" or "x.y", where x and y are
# numbers, leave others untouched
#  get tag
#  check if it has x.y
#  if it is x.y get y and check if y is number
#  if y is number => increment
#  if it only is x check if x is number
#  if x is number => increment
#  else leave untouched
increment_build_number() {
    [[ $OPT_INC_BUILD_NUMBER -eq 0 ]] && return

    local release=$(get_spec_tag "%{release}")
    local x=$(echo $release | cut -f 1 -d .)
    local y=$(echo $release | cut -s -f 2 -d .)
    local z=$(echo $release | cut -s -f 3- -d .)

    # more than one dot found => don't touch
    [[ -n "$z" ]] && return

    if [[ -n "$y" ]]; then
        if [[ $y =~ ^-?[0-9]+$ ]]; then
            let new_release=$y+1
            echo "Incrementing release: $x.$y -> $x.$new_release"
            sed -i "s/^Release:.*/Release: $x.$new_release/" "$OPT_SPEC"
            return
        else
            # non-numeric after dot => don't touch
            return
        fi
    fi

    if [[ -n "$x" ]]; then
        if [[ $x =~ ^-?[0-9]+$ ]]; then
            let new_release=$x+1
            echo "Incrementing release: $x -> $new_release"
            sed -i "s/^Release:.*/Release: $new_release/" "$OPT_SPEC"
            return
        fi
    fi
}

quote() {
    [[ $# -gt 0 ]] && printf "%q " "$@" |sed 's/ $//'
}

rpm_quote() {
    quote "$@" |sed 's/\\/&&/g'
}

run_installdeps() {
    # Refresh repos before installing dependencies
    sb2 -t "$target" -m sdk-install -R zypper --non-interactive ref
    verify_target_dependencies
}

run_apply() {
    rpm_dir="$(dirname "$OPT_SPEC")"
    submodule=""
    if [ ! -z "$OPT_SUBMODULE" ]; then
        submodule="$OPT_SUBMODULE"
    else
        # try to detect submodule
        submodule="$(git submodule | awk '{print $2}')"
    fi

    if [ ! -z "$submodule" ]; then
        if [ ! -d "$submodule" ]; then
            echo "Submodule with directory $submodule not found. Define with -m"
            exit 1
        fi
        pushd "$submodule" >/dev/null
    fi

    reverse="cat"
    if [ "$APPLY_REVERSE" -eq 1 ]; then
        reverse="tac"
    fi
    for p in $(sed -e '/^%patch/!d' -e 's/^%patch\([0-9]*\).*/\1/' "$OPT_SPEC" | $reverse); do
        op="$(grep "^%patch${p}" "$OPT_SPEC" | awk '{print $2}')"
        patch_file="$(grep "^Patch$p:" "$OPT_SPEC" | awk '{print $2}')"
        if [ "$APPLY_REVERSE" -eq 1 ]; then
            echo "Reversing $patch_file"
            patch -R $op < "$rpm_dir/$patch_file"
        else
            echo "Applying $patch_file"
            patch $op < "$rpm_dir/$patch_file"
        fi
    done

    if [ ! -z "$submodule" ]; then
        popd >/dev/null
    fi
}

run_build() {
    # intended to provide mb build behaviour
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    if [[ $BUILD_NOPREP ]]; then
        sed -e '/^%patch/d' "$OPT_SPEC" > "$tmp_spec"
    else
        cp "$OPT_SPEC" "$tmp_spec"
    fi

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        rm -f "$_basedir/RPMS/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$(rpm_quote "$BUILD_JOBS")" \
            --define "_rpmdir $_basedir/RPMS" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            "${BUILD_NOPREP[@]}" \
            -bb \
            "$tmp_spec" \
            "$@"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_prep() {
    verify_target_dependencies

    increment_build_number;
    local tmp_spec="$OPT_SPEC.$$"
    # TODO maybe add toggle here for disabling patch applying?
    cp "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}
    (
        cd_to_spec_setup_dir;
        rm -f "$_basedir/RPMS/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            "${BUILD_DEBUG[@]}" \
            --define "_smp_mflags -j$BUILD_JOBS" \
            --define "_rpmdir $_basedir/RPMS" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bp --short-circuit \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_qmake() {
    if [[ "$OPT_SPEC" ]] && check_spec_supports_qtc_silent; then
        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        # This is a good time to verify the target dependencies as per mb
        verify_target_dependencies
        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "qtc_builddir $_basedir" \
                --define "qtc_make true ignoring make" \
                --define "qtc_qmake5 %qmake5 $(rpm_quote "$@")" \
                --define "qtc_qmake %qmake $(rpm_quote "$@")" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET qmake "$@"
    fi
}

run_make() {
    if [[ "$OPT_SPEC" ]] && check_spec_supports_qtc_silent; then

        local tmp_spec="$OPT_SPEC.$$"
        cp -a "$OPT_SPEC" "$tmp_spec"

        # get rid of potential windows linefeeds
        sed -i "s/\x0D$//g" "$tmp_spec"

        local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
        build_tgt=${build_tgt%-gnueabi}
        (
            cd_to_spec_setup_dir;
            sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
                --define "noecho 1" \
                --define "qtc_builddir $_basedir" \
                --define "qtc_qmake5 true ignoring qmake" \
                --define "qtc_qmake true ignoring qmake" \
                --define "qtc_make make %{?_smp_mflags} $(rpm_quote "$@")" \
                -bc --short-circuit \
                "$tmp_spec"
        )
        local rc=$?
        rm -f "$tmp_spec"
        return $rc
    else
        sb2 -t $OPT_TARGET make "$@"
    fi
}

run_install() {
    # Intentionally undocumented. The --docheck option is used internally by run_rpm()
    local maybe_nocheck=(--nocheck)
    if [[ ${1:-} == --docheck ]]; then
        maybe_nocheck=()
    fi

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    # Install to buildroot which should be rsync'ed to /opt/sdk/$package on device
    (
        cd_to_spec_setup_dir;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "qtc_builddir $_basedir" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_skip_install_processing 1" \
            --buildroot="$buildroot" \
            -bi --short-circuit "${maybe_nocheck[@]}" \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_rpm() {
    # Intentionally undocumented. The --noinstall option is there mostly for
    # self-test use, to avoid the need to deal with multiple invocations of one
    # stub during one test case execution
    if [[ ${1:-} != --noinstall ]]; then
        run_install --docheck
    fi

    local build_tgt=$(sb2 -t $OPT_TARGET gcc -dumpmachine)
    build_tgt=${build_tgt%-gnueabi}

    local tmp_spec="$OPT_SPEC.$$"
    cp -a "$OPT_SPEC" "$tmp_spec"

    try_to_make_changelog >> "$tmp_spec"

    # get rid of potential windows linefeeds
    sed -i "s/\x0D$//g" "$tmp_spec"

    fix_package_version "$tmp_spec"

    (
        increment_build_number;
        cd_to_spec_setup_dir;
        rm -f "$_basedir/RPMS/"*.rpm;
        sb2 -t $OPT_TARGET rpmbuild --build-in-place --target=$build_tgt \
            --define "noecho 1" \
            --define "qtc_builddir $_basedir" \
            --define "_rpmdir $_basedir/RPMS" \
            --define "_sourcedir $_basedir/rpm" \
            --define "_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm" \
            --buildroot="$buildroot" \
            -bb --short-circuit --noclean \
            "$tmp_spec"
    )
    local rc=$?
    rm -f "$tmp_spec"
    return $rc
}

run_deploy() {
    [[ "$device_type" ]] || fatal "deploy must have a valid --device"
    local fail_text="deploy must use one of --pkcon, --rsync , --sdk or --zypper"
    [[ -z ${1:-} ]] && fatal $fail_text

    local retcode=0

    while [[ $1 ]]; do
        case "$1" in
            "--sdk" | "--pkcon" )
                local method;
                if [[ "$1" == "--sdk" ]]; then
                    method="sdk-deploy-rpm"
                else
                    method="pkcon --plain --noninteractive install-local"
                fi
                shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find RPMS -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as $deviceuser -av ${rpms} $device_ip:/home/$deviceuser/RPMS/
                [[ $? -ne 0 ]] && return 1
                ssh_as $deviceuser $method ${rpms}
                retcode=$?
                ssh_as $deviceuser rm -f ${rpms}
                ;;
            "--zypper" ) shift
                run_rpm
                [[ $? -ne 0 ]] && return 1
                rpms=$(find RPMS -name '*.rpm' -a ! -name '*-debug*.rpm')
                rsync_as root -av ${rpms} $device_ip:/root/RPMS/
                [[ $? -ne 0 ]] && return 1
                ssh_as root zypper --non-interactive --quiet in -f ${rpms}
                retcode=$?
                ssh_as root rm -f ${rpms}
                ;;
            "--rsync" ) shift
                run_install
                [[ $? -ne 0 ]] && return 1
                name=$(get_spec_tag "%{name}")
                rsync_as $deviceuser -av ${buildroot}/. $device_ip:/opt/sdk/$name
                retcode=$?
                ;;
            *)
                fatal $fail_text ;;
        esac
    done

    [[ $retcode -eq 0 ]] || { echo "Deploy failed"; return 1; }
}

get_shared_dir() {
    echo "$OPT_SHARED_DIR"
}

inside_build_engine() [[ -f /etc/mer-sdk-vbox ]]
inside_git_worktree() { git status &>/dev/null; }

# this is same as basename $0
ME=${0/#*\//}

################################################################################
if [[ $1 != --self-test ]]; then  ###  M A I N  EXECUTION BEGINS HERE  #########
################################################################################

# option variables
OPT_SPEC=
OPT_TARGET=
OPT_DEVICE=
OPT_PKGDIR="./rpm"
OPT_PROJDIR=
OPT_NEEDSPEC=
OPT_PEDANTIC=0
# Do not enable implicitly when used inside a build engine VM as there is not UI
# in Qt Creator that would allow to override this
OPT_FIX_VERSION=$(inside_git_worktree && ! inside_build_engine && echo 1)
OPT_FIX_VERSION_HINT=
OPT_GIT_CHANGE_LOG=
OPT_GIT_CHANGE_LOG_ARGS=
OPT_SHARED_DIR=/etc/mersdk/share
OPT_INC_BUILD_NUMBER=0
OPT_SUBMODULE=""
deviceuser=nemo

# Virtualbox environment will install in this hardcoded location
if inside_build_engine; then
    buildroot=/home/deploy/installroot
else
    buildroot="$PWD/installroot"
fi

while [[ "$1" ]]; do
    # only set variables in this loop
    case "$1" in
        "-t" | "--target") shift
            OPT_TARGET="$1"; shift
            ;;
        "-f" | "--shared-folder") shift
            OPT_SHARED_DIR="$1"; shift
            ;;
        "-d" | "--device") shift
            OPT_DEVICE="$1"; shift
            ;;
        "-p" | "--projectdir") shift
            OPT_PROJDIR="$1"; shift
            OPT_PKGDIR="$OPT_PROJDIR"/rpm
            [[ -d "$OPT_PROJDIR" ]] || fatal "'$OPT_PROJDIR' is not a directory"
            ;;
        "-s" | "--specfile" ) shift
            OPT_SPEC="$1"; shift
            ;;
        "-i" | "--increment" ) shift
            OPT_INC_BUILD_NUMBER=1
            ;;
        "-P" | "--pedantic" ) shift
            OPT_PEDANTIC=1
            ;;
        "-x" | "--fix-version" ) shift
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=
            ;;
        "-x="* | "--fix-version="* )
            OPT_FIX_VERSION=1
            OPT_FIX_VERSION_HINT=${1#*=}
            if [[ ! $(git tag --list "$OPT_FIX_VERSION_HINT") ]]; then
                fatal "'$OPT_FIX_VERSION_HINT' no such Git tag"
            fi
            shift
            ;;
        "-X" | "--no-fix-version" ) shift
            OPT_FIX_VERSION=
            OPT_FIX_VERSION_HINT=
            ;;
        "-c" | "--git-change-log" ) shift
            OPT_GIT_CHANGE_LOG=1
            ;;
        "-c="* | "--git-change-log="* )
            OPT_GIT_CHANGE_LOG=1
            OPT_GIT_CHANGE_LOG_ARGS="${1#*=}"
            shift
            ;;
        "-m" | "--submodule" ) shift
            OPT_SUBMODULE="$1"; shift
            ;;
        install | rpm | deploy | build | installdeps | apply | prep )
            OPT_NEEDSPEC=1;
            break
            ;;
        qmake | make | run | ssh )
            break
            ;;
        --version )
            echo "$ME, version VERSION_FROM_SPEC"
            exit 0
            ;;
        --help )
            usage
            exit 0
            ;;
        *)
            short_usage quit
            ;;
    esac
done

if [[ -n "$OPT_SPEC" ]]; then
    try_to_make_spec "$OPT_SPEC"
    [[ -f "$OPT_SPEC" ]] || fatal "'$OPT_SPEC' doesn't exist (and could not be made from a yaml)"
fi

if [[ -n "$OPT_DEVICE" ]]; then
    [[ -f $(get_shared_dir)/devices.xml ]] || fatal "Unable to open $(get_shared_dir)/devices.xml"
    get_device "$OPT_DEVICE" < $(get_shared_dir)/devices.xml || fatal "'$OPT_DEVICE' not found in devices.xml"
fi

if [[ ! "$OPT_TARGET" ]]; then
    if [[ -f ~/.scratchbox2/config ]]; then
        . ~/.scratchbox2/config
        OPT_TARGET=$DEFAULT_TARGET
    fi
    [[ "$OPT_TARGET" ]] || fatal "You must specify an sb2 target or have a default configured"
fi

[[ -d ~/.scratchbox2/$OPT_TARGET ]] || fatal "$OPT_TARGET is an invalid sb2 target"

# spec rules are complex:
#  a .spec is required for some but not all operations
#  if -s is given then
#    if it does not exist then specify tries to make it
#    if it exists it will be used
#  if there is a rpm/*.spec then that is used
#  if there is a rpm/*.yaml then a spec is made and used

if [[ ! "$OPT_SPEC" ]]; then
    # set nullglob on so that the shell glob expansions will return
    # empty if files are not found
    shopt -s nullglob
    spec_files=("$OPT_PKGDIR"/*.spec)
    numspec=${#spec_files[@]}
    if [[ $numspec -gt 1 ]]; then
        [[ $OPT_NEEDSPEC ]] && fatal "Too many spec files - please use -s to identify which one to use"
        echo "Too many spec files - not using any. Use -s to identify a specific one"
        # OPT_SPEC is not set
    fi

    if [[ $numspec -eq 0 ]]; then
        # No spec, try to find a yaml
        yaml_files=("$OPT_PKGDIR"/*.yaml)
        numyaml=${#yaml_files[@]}
        if [[ $numyaml -eq 1 ]]; then
            theyaml=("$OPT_PKGDIR"/*.yaml)
            try_to_make_spec_from_yaml "${theyaml[0]}"
            spec_files=("$OPT_PKGDIR"/*.spec)
            numspec=${#spec_files[@]}
        else
            [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #1"
        fi
    fi

    if [[ $numspec -eq 1 ]]; then
        thespec=("$OPT_PKGDIR"/*.spec)
        OPT_SPEC="${thespec[0]}"
    else
        # this is because we did try_to_make_spec_from_yaml and failed
        [[ $OPT_NEEDSPEC ]] && fatal "No spec file found in '$OPT_PKGDIR/' and couldn't make one from a yaml #2"
    fi

    # unset nullglob so that any further globbing works normally
    shopt -u nullglob
fi

# Now if there is a spec given, make sure it is up-to-date
if [[ "$OPT_SPEC" ]]; then
    # turn 'OPT_SPEC' into an absolute path
    OPT_SPEC=$(readlink -f "$OPT_SPEC")
    ensure_spec_newer_than_yaml
fi

case "$1" in
    qmake | make | install | rpm | deploy | prep )
        cmd=run_$1
        if [[ "$OPT_PEDANTIC" -eq 1 && "$OPT_SPEC" ]]; then
            check_spec_supports_qtc
        fi
        shift
        ;;
    apply )
        cmd=run_$1; shift
        APPLY_REVERSE=0
        while [[ "$1" ]]; do
            case "$1" in
                -R) shift
                    APPLY_REVERSE=1 ;;
                *)
                    short_usage quit
                    ;;
            esac
        done
        ;;
    build | installdeps )
        cmd=run_$1; shift
        BUILD_DEBUG=(--define "debug_package %{nil}")
        BUILD_JOBS=
        BUILD_NOPREP=(--noprep)
        while [[ "$1" ]]; do
            case "$1" in
                -d|--enable-debug) shift
                    BUILD_DEBUG=() ;;
                -j*)
                    # support giving -j with and without space between
                    # it and the 'n'
                    if [[ ${#1} -gt 2 ]]; then
                        BUILD_JOBS=${1:2}; shift
                    else
                        [[ -z "$2" ]] && short_usage quit
                        BUILD_JOBS="$2"; shift 2;
                    fi
                    ;;
                -p|--doprep) shift
                    BUILD_NOPREP=()
                    ;;
                *)
                    break
                    ;;
            esac
        done
        [[ $BUILD_JOBS ]] || BUILD_JOBS=$(getconf _NPROCESSORS_ONLN)
        ;;
    run | ssh ) shift
        if [[ "$OPT_DEVICE" ]]; then
            cmd="ssh_as $deviceuser"
        else
            cmd=""
        fi
        ;;
    *)
        short_usage quit
        ;;
esac

$cmd "$@"

##############################################################################
exit; fi ###  S E L F - T E S T  EXECUTION BEGINS HERE #######################
##############################################################################

set -o nounset

SELF=$(readlink -f "$0")

: ${MB2_SELF_TEST_VERBOSE:=}

temp=$(mktemp -d) || exit
trap "rm -rf '$temp'" EXIT
cd "$temp" || exit

mkdir stubs || exit
STUBS_DIR=$(readlink -f stubs)
export PATH="$STUBS_DIR:$PATH"

################################################################################
# Test utils

tc_num=0
tc_failed_num=0

set_up_ts() {
    local ts=$1
    TS_NAME=$2
    ${ts}_ts_set_up "${@:3}"
    if [[ $? -ne 0 ]]; then
        fatal "Test suite set-up failed: $ts"
    fi
}

tear_down_ts() {
    local ts=$1
    ${ts}_ts_tear_down
    if [[ $? -ne 0 ]]; then
        fatal "Test suite tear-down failed: $ts"
    fi
    TS_NAME=
}

KNOWN_ISSUES=()
KNOWN_ISSUE() {
    KNOWN_ISSUES=(${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"} "$1")
}

run_tc() {
    local tc=$1
    TC_NAME=$2
    local args=("${@:3}")

    let tc_num++
    echo "*** Executing test case: ${TS_NAME:+$TS_NAME - }$TC_NAME"

    local known_issue
    for known_issue in ${KNOWN_ISSUES[@]:+"${KNOWN_ISSUES[@]}"}; do
        echo "    Known issue: $known_issue"
    done
    KNOWN_ISSUES=()

    local stderr=
    { stderr=$(${tc}_tc ${args[@]:+"${args[@]}"} 3>&1 1>&2 2>&3 3>&-); } 2>&1
    local rc=$?

    if [[ $rc -ne 0 ]]; then
        let tc_failed_num++
    fi

    if [[ $rc -ne 0 || $MB2_SELF_TEST_VERBOSE ]]; then
        cat <<END
  ** Stderr     ** [[
$stderr
]]
END
    fi

    return $rc
}

arg_pass_stub_create() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args

        touch "$results" || return
        cat >"$stub" <<END || return
#!/bin/bash
echo "stub invoked: \$0 \$(printf "%q " "\$@")" >&2
{ [[ \$# -ne 0 ]] && printf "%q\\n" "\$@"; } >"$results"
exit 0
END
        chmod +x "$stub" || return
        shift
    done
}

arg_pass_stub_remove() {
    while [[ ${1:-} ]]; do
        local stub=$STUBS_DIR/$1
        local results=$STUBS_DIR/$1.args
        rm -f "$stub" || return
        rm -f "$results" || return
        shift
    done
}

arg_pass_stub_results() {
    local results=$STUBS_DIR/$1.args
    [[ -e $results ]] && cat "$results"
}

arg_pass_stub_clear() {
    while [[ ${1:-} ]]; do
        local results=$STUBS_DIR/$1.args
        rm -f "$results" || return
        shift
    done
}

expect_args() {
    [[ $# -ne 0 ]] && printf "%q\n" "$@" || true
}

DEFAULT_TARGET=$(. ~/.scratchbox2/config; echo "$DEFAULT_TARGET")
DEFAULT_JOBS=$(getconf _NPROCESSORS_ONLN)

if inside_build_engine; then
    DEFAULT_DEVICE="Sailfish OS Emulator"
else
    echo "Note: Skipping test cases involving device connection - not inside a Sailfish OS build engine" >&2
    DEFAULT_DEVICE=
fi

################################################################################
# Test the rpm_quote function

rpm_quote_tc() {
    arg_pass_stub_create make || return

    # Create an minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name: test
Version: 1.0
Release: 0
Summary: Test
License: BSD

# This would normally come from the environment
%{!?make:%define make make}

%description
Test

%build
%make "x  y"
END

    rpmbuild -bc --short-circuit --noprep --build-in-place --define "_sourcedir $(readlink -f rpm)" rpm/test.spec \
        --define "make make $(rpm_quote "a b" "c  d" e f)" >&2 || return
    local rc=0 expected= actual= diff=
    expected=$(expect_args "a b" "c  d" e f "x  y")
    actual=$(arg_pass_stub_results make) || return
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        rc=1
        cat <<END
Test case failed: $TC_NAME
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
    fi

    arg_pass_stub_remove make || return
    rm -f rpm/test.spec || return
    rmdir rpm || return

    return $rc
}

run_tc rpm_quote "Test RPM macro escaping"

################################################################################
# Test sb2 argument passing

sb2_arg_pass_ts_set_up() {
    arg_pass_stub_create sb2 || return

    # Create an empty spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
# Just say 'define qtc_qmake' to make check_spec_supports_qtc_silent happy
END
}

sb2_arg_pass_ts_tear_down() {
    arg_pass_stub_remove sb2 || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

sb2_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear sb2 || return
    "$SELF" "${args[@]}" || return
    local actual_raw= actual= diff=
    actual_raw=$(arg_pass_stub_results sb2) || return
    actual=$(sed -e 's,/tmp\.[^/]\+,/@TMPDIR@,' \
                 -e "s,/home/deploy,/tmp/@TMPDIR@," \
                 -e 's,/test\.spec\.[^/]\+,/@TEST_SPEC@,' <<<"$actual_raw")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
  ** Actual RAW ** [[
$actual_raw
]]
END
        return 1
    fi
}

set_up_ts sb2_arg_pass "Passing arguments to sb2"

KNOWN_ISSUE "Does not disable debug by default (ignores --enable-debug)"
KNOWN_ISSUE "Passes -j without argument"
KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "prep" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define '_smp_mflags -j' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bp --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    prep "a b" "c  d" e f

run_tc sb2_arg_pass "build" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'debug_package %{nil}' \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "build with debug" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define "_smp_mflags -j$(rpm_quote "bad  1")" \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot=/tmp/@TMPDIR@/installroot \
        -bb \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@ \
        "a b" "c  d" e f)" \
    build --doprep --enable-debug -j "bad  1" "a b" "c  d" e f

run_tc sb2_arg_pass "qmake" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define 'qtc_make true ignoring make' \
        --define "qtc_qmake5 %qmake5 $(rpm_quote "a b" "c  d" e f)" \
        --define "qtc_qmake %qmake $(rpm_quote "a b" "c  d" e f)" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    qmake "a b" "c  d" e f

run_tc sb2_arg_pass "make" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define 'qtc_qmake5 true ignoring qmake' \
        --define 'qtc_qmake true ignoring qmake' \
        --define "qtc_make make %{?_smp_mflags} $(rpm_quote "a b" "c  d" e f)" \
        -bc --short-circuit \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    make "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "install" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_skip_install_processing 1' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bi --short-circuit --nocheck \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    install "a b" "c  d" e f

KNOWN_ISSUE "Silently ignores extra arguments"
run_tc sb2_arg_pass "rpm" \
    "$(expect_args \
        -t "$DEFAULT_TARGET" rpmbuild --build-in-place --target= \
        --define 'noecho 1' \
        --define 'qtc_builddir /tmp/@TMPDIR@' \
        --define '_rpmdir /tmp/@TMPDIR@/RPMS' \
        --define '_sourcedir /tmp/@TMPDIR@/rpm' \
        --define '_rpmfilename %%{name}-%%{version}-%%{release}.%%{arch}.rpm' \
        --buildroot='/tmp/@TMPDIR@/installroot' \
        -bb --short-circuit --noclean \
        /tmp/@TMPDIR@/rpm/@TEST_SPEC@)" \
    rpm --noinstall "a b" "c  d" e f

tear_down_ts sb2_arg_pass

################################################################################
# Test arguments passing to commands invoked by rpmbuild

rpmbuild_arg_pass_sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "$@" >&2
            ;;
        rpmspec)
            exec "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

rpmbuild_arg_pass_ts_set_up() {
    RPMBUILD_STUBS=(qmake make)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    # Create an sb2 stub
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f rpmbuild_arg_pass_sb2_stub)
rpmbuild_arg_pass_sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

%{!?qtc_qmake:%define qtc_qmake %qmake}
%{!?qtc_qmake5:%define qtc_qmake5 %qmake5}
%{!?qtc_make:%define qtc_make make}
%{?qtc_builddir:%define _builddir %qtc_builddir}
Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
%setup -q -n %{name}-%{version}

%build
%qtc_qmake5 
%qtc_make %{?_smp_mflags}

%install
mkdir -p %{buildroot}

%files
%defattr(-,root,root,-)
END
}

rpmbuild_arg_pass_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    rm -f "$STUBS_DIR/sb2" || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
}

rpmbuild_arg_pass_tc() {
    local all_expected=("${@:1:${#RPMBUILD_STUBS[*]}}")
    local args=("${@:1+${#RPMBUILD_STUBS[*]}}")

    local rc=0

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}"
    "$SELF" "${args[@]}" || return
    local i=
    for ((i=0; i<${#RPMBUILD_STUBS[@]}; i++)); do
        local stub= expected= actual= diff=
        stub=${RPMBUILD_STUBS[i]}
        expected=${all_expected[i]}
        actual=$(arg_pass_stub_results "$stub")
        if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
            rc=1
            cat <<END
Test case failed: $TC_NAME/$i
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Failed for ** $stub
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        fi
    done

    return $rc
}

set_up_ts rpmbuild_arg_pass "Passing arguments to commands invoked by rpmbuild"

run_tc rpmbuild_arg_pass "build" \
    "$(expect_args )" \
    "$(expect_args -j"$DEFAULT_JOBS")" \
    build

run_tc rpmbuild_arg_pass "qmake" \
    "$(expect_args "a b" "c  d" e f)" \
    "$(expect_args )" \
    qmake "a b" "c  d" e f

KNOWN_ISSUE "Passes extra -j to make"
if [[ $DEFAULT_JOBS -ne 1 ]]; then
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args -j"$DEFAULT_JOBS" "a b" "c  d" e f -j"$DEFAULT_JOBS")" \
        make "a b" "c  d" e f
else
    run_tc rpmbuild_arg_pass "make" \
        "$(expect_args )" \
        "$(expect_args "a b" "c  d" e f)" \
        make "a b" "c  d" e f
fi

tear_down_ts rpmbuild_arg_pass

################################################################################
# Test arguments passing to commands invoked using run|ssh subcommand

ssh_arg_pass_ts_set_up() {
    :
}

ssh_arg_pass_ts_tear_down() {
    :
}

ssh_arg_pass_tc() {
    local expected=$1
    local args=("${@:2}")

    local actual= diff=
    actual=$("$SELF" "${args[@]}")
    if ! diff=$(diff <(cat <<<"$expected") <(cat <<<"$actual")); then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(quote "${args[@]}")
  ** Mismatch   ** [[
$diff
]]
  ** Expected   ** [[
$expected
]]
  ** Actual     ** [[
$actual
]]
END
        return 1
    fi
}

set_up_ts ssh_arg_pass "Passing arguments using run|ssh subcommand"

run_tc ssh_arg_pass "local - just spaces" \
    "$(printf '%q ' 'a b' 'c  d' e f)" \
    run printf '%q ' 'a b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and newlines" \
    "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
    run printf '%q'$'\n' 'echo b' 'c  d' e f

run_tc ssh_arg_pass "local - spaces and backslashes" \
    "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
    run printf '%q\n' 'a\ b' 'c  d' e f

if [[ $DEFAULT_DEVICE ]]; then
    run_tc ssh_arg_pass "remote - just spaces" \
        "$(printf '%q ' 'a b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q ' 'a b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and newlines" \
        "$(printf '%q'$'\n' 'echo b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q'$'\n' 'echo b' 'c  d' e f

    run_tc ssh_arg_pass "remote - spaces and backslashes" \
        "$(printf '%q\n' 'a\ b' 'c  d' e f)" \
        --device "$DEFAULT_DEVICE" run printf '%q\n' 'a\ b' 'c  d' e f
fi

tear_down_ts ssh_arg_pass

################################################################################
# Test --fix-version behavior

fix_version_ts_set_up() {
    COMMITS_U=()
    COMMITS_D=()

    get_commit() {
        eval echo \${COMMITS_${1:0:1}[${1:1}]} |grep .
    }

    local i= commit= tag_name= tag_object=

    git init . --quiet || return
    git config user.email "john@doe.com" || return
    git config user.name "John Doe" || return

    git checkout -b upstream --quiet
    for ((i=0; i<=30; i++)); do
        printf "U%02d\n" "$i" > U
        git add U || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$i days" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<U)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_U=(${COMMITS_U[*]:-} $commit)
    done

    git checkout -b downstream "${COMMITS_U[10]}" --quiet || return
    for ((i=0; i<=20; i++)); do
        if [[ $i -eq 10 ]]; then
            git merge --no-commit "${COMMITS_U[20]}" --quiet 2>/dev/null || return
        fi
        printf "D%02d\n" "$i" > D
        git add D || return
        date="@$(TZ=UTC date --date="2000-01-01 00:00:00 UTC +$((i+10)) days +12 hours" +%s) +0000"
        GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
            git commit --message "$(<D)" --quiet || return
        commit=$(git rev-list --max-count=1 --abbrev-commit HEAD) || return
        COMMITS_D=(${COMMITS_D[*]:-} $commit)
    done

    while [[ ${1:-} ]]; do
        case $1 in
            --tag)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                git tag "$tag_name" "$tag_object" || return
                shift 2
                ;;
            --tag-a)
                tag_name=$2
                tag_object=$(get_commit $3) || return
                tag_annotation="$3"
                git tag -a -m "$tag_annotation" "$tag_name" "$tag_object" || return
                shift 2
                ;;
            *)
                return 1
                ;;
        esac
        shift
    done
}

fix_version_ts_tear_down() {
    unset COMMITS_U COMMITS_D
    unset -f get_commit
    rm -rf .git || return
    rm -f U D dirty || return
}

fix_version_tc() {
    local dirty=$1 head=$2 expected_raw=$3 hint=${4:-}

    head=$(get_commit "$head") || return

    git reset --hard --quiet || return
    git checkout -B downstream "$head" --quiet || return
    if [[ $dirty == dirty ]]; then
        echo dirty >> D
    fi

    local version_file=version
    local last_stash_file=last_stash

    echo "Version:" > $version_file

    (
        git() (
            echo "stub invoked: git" >&2
            if [[ $1 == stash && $2 == create ]]; then
                date="@$(TZ=UTC date --date="2000-12-31 18:00:00 UTC" +%s) +0000"
                GIT_AUTHOR_DATE=$date GIT_COMMITTER_DATE=$date \
                    command git stash create |tee $last_stash_file
            else
                command git "$@"
            fi
        )

        OPT_FIX_VERSION=1
        OPT_FIX_VERSION_HINT=$hint
        fix_package_version $version_file >&2
    ) || return

    local actual=$(sed 's/^Version: //' $version_file)

    local stash_sha1=
    if [[ -e $last_stash_file ]]; then
        stash_sha1=$(git rev-list --max-count=1 --abbrev-commit "$(<$last_stash_file)")
    fi

    local expected=$expected_raw i=
    for ((i=0; i<=30; i++)); do
        expected=${expected//@U$i@/${COMMITS_U[$i]}}
    done
    for ((i=0; i<=20; i++)); do
        expected=${expected//@D$i@/${COMMITS_D[$i]}}
    done
    expected=${expected//@STASH@/${stash_sha1:-<none>}}

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Arguments    ** $(printf "%q " "$@")
  ** Expected     ** '$expected'
  ** Actual       ** '$actual'
  ** Expected RAW ** '$expected_raw'
  ** Git-status   ** [[
$(git status)
]]
  ** Git-log      ** [[
$(git log --graph --decorate --pretty=fuller --all ${stash_sha1:-})
]]
END
        return 1
    fi
}

# Works with Git history like this
#
# U00---...---U10---U11---...---U20---U21---...---U30 <-- upstream
#               \                 \
#                D00---D01---...---D10---D11---...---D20 <-- downstream
#
# Upstream commit dates are 2000-01-01 + <num> days 00:00 UTC, downstream commit dates are
# 2000-01-01 + <num+10> days 12:00 UTC, stashes are 2000-12-31 18:00 UTC.

set_up_ts fix_version "Test --fix-version behavior" \
    --tag v0.1 U5 \
    --tag v0.2 U10 \
    --tag v0.3 U15 \
    --tag v0.4 U20 \
    --tag v0.5 U25 \
    --tag mer/v0.2+git1 D5 \
    --tag mer/v0.4+git1 D11 \
    --tag-a mer/v0.4+git2 D15 \
    --tag mer/v0.4+git3 D20

run_tc fix_version "on tag, clean D5"               clean D5  0.2+git1
run_tc fix_version "ahead tag, clean D7"            clean D7  0.2+git1+downstream.2000''01''18''12''00''00.@D7@
run_tc fix_version "ahead tag, dirty D7"            dirty D7  0.2+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead upstream tag, clean D10"  clean D10 0.4+downstream.2000''01''21''12''00''00.@D10@
run_tc fix_version "on tag, clean D11"              clean D11 0.4+git1
run_tc fix_version "on tag, dirty D11"              dirty D11 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "ahead tag, clean D12"           clean D12 0.4+git1+downstream.2000''01''23''12''00''00.@D12@
run_tc fix_version "ahead tag, dirty D12"           dirty D12 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on annotated, clean D15"        clean D15 0.4+git2
run_tc fix_version "ahead annotated, clean D16"     clean D16 0.4+git2+downstream.2000''01''27''12''00''00.@D16@
run_tc fix_version "ahead annotated, dirty D16"     dirty D16 0.4+git2+downstream.2000''12''31''18''00''00.@STASH@
run_tc fix_version "on tag, clean D15 + hint"       clean D15 0.4+git1+downstream.2000''01''26''12''00''00.@D15@    mer/v0.4+git1
run_tc fix_version "on tag, dirty D15 + hint"       dirty D15 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1
run_tc fix_version "ahead tag, clean D16 + hint"    clean D16 0.4+git1+downstream.2000''01''27''12''00''00.@D16@    mer/v0.4+git1
run_tc fix_version "ahead tag, dirty D16 + hint"    dirty D16 0.4+git1+downstream.2000''12''31''18''00''00.@STASH@  mer/v0.4+git1

tear_down_ts fix_version

################################################################################
# Test the readarray behavior - simplified version implemented as a shell
# function for compatibility with older BASH

readarray_tc() {
    local expected=('  abc *  def  ' '  g  h  i  ')
    local actual=()
    echo "Note: readarray is a $(type -t readarray)" >&2
    readarray -t actual < <(printf "%s\n" "${expected[@]}")
    if ! (
        [[ ${#expected[*]} -eq ${#actual[*]} ]] || exit
        for ((i=0; i<${#expected[*]}; i++)); do
            [[ ${actual[$i]} == "${expected[$i]}" ]] || exit
        done
        ); then
        cat <<END
Test case failed: $TC_NAME
  ** Expected   ** [[
$(declare -p expected)
]]
  ** Actual     ** [[
$(declare -p actual)
]]
END
        return 1
    fi
}

run_tc readarray "Test readarray behavior"

################################################################################
# Test build phases separation

rpmbuild_phases_sb2_stub() {
    echo "stub invoked: $0 $(printf "%q " "$@")" >&2

    local args=("$@")
    bad_args() {
        echo "stub $0: unexpected arguments: $(printf "%q " "${args[@]}")" >&2
    }

    if ! [[ $1 == -t && $3 != -* ]]; then
        bad_args
        return 1
    fi

    shift 2

    case $1 in
        gcc)
            case $2 in
                -dumpmachine)
                    echo "i486-meego-linux"
                    ;;
                *)
                    bad_args
                    return 1
                    ;;
            esac
            ;;
        rpmbuild)
            # rpmbuild writes some progress messages to stdout
            exec "$@" >&2
            ;;
        rpmspec)
            exec "$@"
            ;;
        *)
            bad_args
            return 1
            ;;
    esac
}

rpmbuild_phases_ts_set_up() {
    RPMBUILD_STUBS=(my_setup qmake make my_install my_check)
    arg_pass_stub_create "${RPMBUILD_STUBS[@]}"

    # Create an sb2 stub
    cat >"$STUBS_DIR/sb2" <<END || return
#!/bin/bash
$(declare -f rpmbuild_phases_sb2_stub)
rpmbuild_phases_sb2_stub "\$@"
END
    chmod +x "$STUBS_DIR/sb2" || return

    # Create a minimal spec file
    mkdir rpm || return
    cat >rpm/test.spec <<END || return
Name:       test

# These would normally come from the environment
%{!?qmake:%define qmake qmake}
%{!?qmake5:%define qmake5 qmake}

# This is to not require meego-rpm-config installed for self-test execution
%global __os_install_post %{nil}

%{!?qtc_qmake:%define qtc_qmake %qmake}
%{!?qtc_qmake5:%define qtc_qmake5 %qmake5}
%{!?qtc_make:%define qtc_make make}
%{?qtc_builddir:%define _builddir %qtc_builddir}
Summary:    Test
Version:    0.1
Release:    1
Group:      Qt/Qt
License:    LICENSE
URL:        http://example.org/
Source0:    %{name}-%{version}.tar.bz2

%description
Test

%prep
my_setup

%build
%qtc_qmake5
%qtc_make %{?_smp_mflags}

%install
mkdir -p %{buildroot}
my_install

# Verifies that --noclean is used
touch %{buildroot}/foo

%check
my_check

%files
%defattr(-,root,root,-)
/foo
END
}

rpmbuild_phases_ts_tear_down() {
    arg_pass_stub_remove "${RPMBUILD_STUBS[@]}" || return
    rm -f "$STUBS_DIR/sb2" || return
    rm -f rpm/test.spec || return
    rmdir rpm || return
    rm -f RPMS/test-0.1-1.i486.rpm || return
    ! [[ -d RPMS ]] || rmdir RPMS || return
}

rpmbuild_phases_tc() {
    local expected=$1
    local args=("${@:2}")

    arg_pass_stub_clear "${RPMBUILD_STUBS[@]}" || return
    rm -f RPMS/test-0.1-1.i486.rpm || return

    "$SELF" "${args[@]}" || return

    local actual=
    if arg_pass_stub_results my_setup &>/dev/null; then
        actual="+prep"
    else
        actual="-prep"
    fi

    if arg_pass_stub_results qmake &>/dev/null; then
        actual="$actual +qmake"
    else
        actual="$actual -qmake"
    fi

    if arg_pass_stub_results make &>/dev/null; then
        actual="$actual +make"
    else
        actual="$actual -make"
    fi

    if arg_pass_stub_results my_install &>/dev/null; then
        actual="$actual +install"
    else
        actual="$actual -install"
    fi

    if arg_pass_stub_results my_check &>/dev/null; then
        actual="$actual +check"
    else
        actual="$actual -check"
    fi

    if [[ -e RPMS/test-0.1-1.i486.rpm ]]; then
        if rpm -q --requires -p RPMS/test-0.1-1.i486.rpm |grep -q '^rpmlib(ShortCircuited)'; then
            actual="$actual +rpm (short-circuited)"
        else
            actual="$actual +rpm"
        fi
    else
        actual="$actual -rpm"
    fi

    if [[ $actual != "$expected" ]]; then
        cat <<END
Test case failed: $TC_NAME
  ** Command    ** $ME $(printf "%q " "${args[@]}")
  ** Expected   ** $expected
  ** Actual     ** $actual
END
        return 1
    fi

    return 0
}

set_up_ts rpmbuild_phases "Separating build phases"

run_tc rpmbuild_phases "prep" \
    "+prep -qmake -make -install -check -rpm" prep
run_tc rpmbuild_phases "build" \
    "-prep +qmake +make +install +check +rpm" build
run_tc rpmbuild_phases "build --doprep" \
    "+prep +qmake +make +install +check +rpm" build --doprep
run_tc rpmbuild_phases "qmake" \
    "-prep +qmake -make -install -check -rpm" qmake
run_tc rpmbuild_phases "make" \
    "-prep -qmake +make -install -check -rpm" make
run_tc rpmbuild_phases "install" \
    "-prep -qmake -make +install -check -rpm" install
KNOWN_ISSUE "Produces short-circuited RPM"
run_tc rpmbuild_phases "rpm" \
    "-prep -qmake -make +install +check +rpm (short-circuited)" rpm

tear_down_ts rpmbuild_phases


################################################################################

if [[ $tc_failed_num -eq 0 ]]; then
    echo "*** All $tc_num tests passed"
else
    echo "*** $tc_failed_num out of $tc_num failed"
fi

# For Emacs:
# Local Variables:
# indent-tabs-mode:nil
# tab-width:4
# mode: sh
# End:
# For VIM:
# vim:set softtabstop=4 shiftwidth=4 tabstop=4 expandtab:
