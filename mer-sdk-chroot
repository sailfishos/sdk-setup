#!/bin/bash
# mer-sdk-chroot

# TODO
#
# Support a Mer clean setup (ie no .oscrc)
# Support multiple shells (ie split setup/entry)

usage()
{
    cat <<EOF
    usage: sudo <enter|on|off> $1 [-u <user>] [-m <all|none|home>] [-r <SDK root path>]
       The Mer chroot SDK

       -u  System user to link into SDK (not needed if using sudo)
       -m  Devices to bind mount from host: none, all (default)
           or just $HOME
       -r The root of the SDK to use - normally derived from the
          pathname of $0

EOF
    return 0
}

if [[ $EUID -ne 0 ]]; then
    echo "$0 must be run as root - attempting to sudo"
    exec sudo $0 "$@"
fi

# Use the SUDO value if present
user=$SUDO_USER || true;

bind_mount_devices="yes";
bind_mount_home="yes";
while getopts "u:m:r:" opt; do
    case $opt in
	u ) user=$OPTARG;;
	m )
	    case $OPTARG in
		all) ;;
		home)
		    bind_mount_devices="no";;
		none)
		    bind_mount_devices="no";
		    bind_mount_home="no";;
		*)  echo "Only 'none', 'all' or 'home' are permitted for -m"
		    usage
		    exit 1;;
	    esac ;;
	r ) sdkroot=$OPTARG;;
	\? ) usage
            exit 1;;
	: ) echo "Option -$OPTARG requires an argument." >&2
	    usage
	    exit 1;;
	* ) usage
            exit 1;;
    esac
done
shift $(($OPTIND - 1))

if [[ -z "${sdkroot}" ]] ; then
    sdkroot=$(dirname $(readlink -f $0))
else
    sdkroot=$(readlink -f $sdkroot)
fi

if [[ -f ${sdkroot}/etc/MerSDK ]] ; then
    echo "${sdkroot} is not a Mer SDK root directory"
    usage
    exit 1
fi

if [[ -z $user ]] ; then
    echo "$0 expects to be run as root using sudo"
    echo "User could not be obtained from \$SUDO_USER, if running as root,"
    echo "please use -u <user>"
    echo
    usage
    exit 1
fi

# From now on, exit if variables not set
set -u

# Make sure normal users can use any dirs we make
umask 022

# What devices do we want to mount from the host?
mountpoints=$(grep "^/" /proc/self/mounts | grep -v bind | cut -f2 -d" " | sort)
mountpoints_r=$(grep "^/" /proc/self/mounts | grep -v bind | cut -f2 -d" " | sort -r)

################################################################
# Mount
prepare_mountpoints() {
    # Setup sdkroot as a bind mountpoint on itself to permit
    # --make-unbindable
    mount --bind $sdkroot $sdkroot
    mount --make-unbindable $sdkroot

    echo "Mounting system directories..."
    mount --bind /proc ${sdkroot}/proc
    mount --bind /proc/sys/fs/binfmt_misc ${sdkroot}/proc/sys/fs/binfmt_misc
    mount --bind /sys ${sdkroot}/sys
    mount --bind /dev ${sdkroot}/dev
    mount --bind /dev/pts ${sdkroot}/dev/pts
    mount --bind /dev/shm ${sdkroot}/dev/shm
    mount --bind /var/lib/dbus ${sdkroot}/var/lib/dbus
    mount --bind /var/run/dbus ${sdkroot}/var/run/dbus

    if [[ $bind_mount_devices == "yes" ]] ; then
	echo "Mounting / and data directories..."
        # Mount all data partitions present in parent
        # sort them in case there are odd depth-mounts
	mkdir -p ${sdkroot}/parentroot
	for mp in $mountpoints; do
	    mkdir -p ${sdkroot}/parentroot
	    mount --bind $mp ${sdkroot}/parentroot/$mp
	done
    fi

    mkdir -p ${sdkroot}/lib/modules/`uname -r`
    mount --bind /lib/modules/`uname -r` ${sdkroot}/lib/modules/`uname -r`
}

prepare_etc() {
    cp /etc/resolv.conf ${sdkroot}/etc/resolv.conf

    [[ -d ${sdkroot}/etc/ssl/certs ]] || {
	mkdir -p ${sdkroot}/etc/ssl/certs
	cp -aL /etc/ssl/certs ${sdkroot}/etc/ssl/
    }
}

prepare_user() {
    # getent is probably best for user data
    sed -i -e "/^${user}:/d" ${sdkroot}/etc/passwd
    getent passwd $user >> ${sdkroot}/etc/passwd
    HOMEDIR=$(getent passwd $user | cut -f6 -d:)

    if [[ $bind_mount_home == "yes" ]] ; then
	echo "Mounting home directory"
	mkdir -p ${sdkroot}${HOMEDIR}
	mount --bind ${HOMEDIR} ${sdkroot}${HOMEDIR}
    fi
    echo "$user ALL=NOPASSWD: ALL" > ${sdkroot}/etc/sudoers.d/$user
    chmod 0440 ${sdkroot}/etc/sudoers.d/$user
}

run_user_hooks() {
    if [[ $bind_mount_home == "yes" ]] ; then
	[[ $(type -t enter_sdk) == "function" ]] && {
	    echo "User entry hook"
	    enter_sdk
	}
    fi
}

err_cleanup() {
    echo
    echo 'Something went wrong during cleanup.'
    echo 'Retrying umounts but manual check is required'
    echo '- press return to confirm'
    echo
    read dummy
    # Now retry cleanup
    set +e
    cleanup
}

umounterrs=""
warn_umount(){
    echo
    echo "Error executing umount of $mountpoint"
    umounterrs="$umounterrs\n$mountpoint"
}

try_umount() {
    mountpoint=$1
    trap "warn_umount" ERR
    umount $mountpoint
    trap - ERR
}

cleanup () {
    [[ $(type -t leave_sdk) == "function" ]] && {
	echo "User exit hook"
	leave_sdk
    }

    if [[ $bind_mount_home == "yes" ]] ; then
	echo "Unmounting $HOMEDIR"
	try_umount ${sdkroot}${HOMEDIR}
    fi

    try_umount ${sdkroot}/lib/modules/`uname -r`

    if [[ $bind_mount_devices == "yes" ]] ; then
	echo "Unmounting / & data directories... ${mountpoints_r}"
        # umount in reverse order
	for mp in ${mountpoints_r}; do
	    try_umount ${sdkroot}/parentroot/$mp
	done
	fi
    echo "Unmounting system directories..."

    try_umount ${sdkroot}/var/run/dbus
    try_umount ${sdkroot}/var/lib/dbus
    try_umount ${sdkroot}/dev/shm
    try_umount ${sdkroot}/dev/pts
    try_umount ${sdkroot}/dev
    try_umount ${sdkroot}/sys
    try_umount ${sdkroot}/proc/sys/fs/binfmt_misc
    try_umount ${sdkroot}/proc

    echo "Done."

    if [[ $umounterrs ]]; then
	echo
	echo "Errors encountered when unmounting the following mountpoints"
	echo -e $umounterrs
    fi
}

ensure_not_mounted() {
    [[ -e ${sdkroot}/.skdoptions ]] && {
	cat <<EOF
This SDK ( ${sdkroot} ) is already mounted.
If you are sure this is not an error and /proc/self/mounts has no mountpoints under it then remove ${sdkroot}/.skdoptions and try again.
EOF
	exit 1;
    }

}
ensure_mounted() {
    [[ -e ${sdkroot}/.skdoptions ]] || {
	cat <<EOF
This SDK ( ${sdkroot} ) does not appear to be mounted.
Have you run $0 mount?

(Check /proc/self/mounts to be sure.)
EOF
	exit 1;
    }
}
stash_mount_options() {
    cat <<EOF > ${sdkroot}/.skdoptions
bind_mount_devices="${bind_mount_devices}"
bind_mount_home="${bind_mount_home}"
user="${user}"
HOMEDIR="${HOMEDIR}"
EOF
}
get_mount_options() {
    [[ -e ${sdkroot}/.skdoptions ]] && {
	source ${sdkroot}/.skdoptions
	rm ${sdkroot}/.skdoptions
    }
}

setup_user_hooks(){
    # Access any user hooks
    [[ -e $HOMEDIR/.mersdkrc ]] && . $HOMEDIR/.mersdkrc
}


action=${1:-enter}

case "$action" in
    enter )
        # setarch is used so uname -a will report i386 - this allows
        # osc to work
	ensure_mounted
	echo "Entering chroot as $user"
	setarch i386 chroot ${sdkroot} su - $user
	;;
    mount  )
	ensure_not_mounted
	trap "err_cleanup; exit" INT TERM EXIT
	prepare_user          # in /etc/passwd
        prepare_mountpoints   # host / and data and /proc and similar
	prepare_etc           # resolv.conf and ssl certs
	setup_user_hooks
	run_user_hooks
	stash_mount_options   # for use when umounting

	cat <<EOF
${sdkroot} is now setup with mountpoints to make it
easier to use as a Mer SDK.
EOF
	trap - INT TERM EXIT
	;;
    umount )
	ensure_mounted
	get_mount_options
	setup_user_hooks
	trap "err_cleanup; exit" INT TERM EXIT
        # Call cleanup manually - if an error occurs then warn and
        # retry
	cleanup
	trap - INT TERM EXIT
	;;
    * )
	echo "$action not recognised"
	;;
esac
